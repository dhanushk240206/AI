class Node:
    def __init__(self, data, level, fval):
        """ Initialize the node with the data, level of the node, and the calculated f-value. """
        self.data = data
        self.level = level
        self.fval = fval
        
    def generate_child(self):
        """ Generate child nodes from the given node by moving the blank space
            either in the four directions {up, down, left, right} """
        x, y = self.find(self.data, '_')
        val_list = [[x, y-1], [x, y+1], [x-1, y], [x+1, y]]
        children = []
        for i in val_list:
            child = self.shuffle(self.data, x, y, i[0], i[1])
            if child is not None:
                child_node = Node(child, self.level+1, 0)
                children.append(child_node)
        return children
        
    def shuffle(self, puz, x1, y1, x2, y2):
        """ Move the blank space in the given direction and if the position values are out
            of limits, return None. """
        if x2 >= 0 and x2 < len(self.data) and y2 >= 0 and y2 < len(self.data[0]):
            temp_puz = self.copy(puz)
            temp = temp_puz[x2][y2]
            temp_puz[x2][y2] = temp_puz[x1][y1]
            temp_puz[x1][y1] = temp
            return temp_puz
        else:
            return None
    
    def copy(self, root):
        """ Copy function to create a similar matrix of the given node. """
        temp = []
        for i in root:
            t = []
            for j in i:
                t.append(j)
            temp.append(t)
        return temp
    
    def find(self, puz, x):
        """ Specifically used to find the position of the blank space. """
        for i in range(len(self.data)):
            for j in range(len(self.data[0])):
                if puz[i][j] == x:
                    return i, j


class Puzzle:
    def __init__(self, size):
        """ Initialize the puzzle size by the specified size, open and closed lists to empty. """
        self.n = size
        self.open = []
        self.closed = []
        
    def accept(self):
        """ Accepts the puzzle from the user. """
        puz = []
        for i in range(self.n):
            temp = input(f"Enter row {i+1} (space-separated values): ").split()
            puz.append(temp)
        return puz
    
    def f(self, start, goal):
        """ Heuristic function to calculate f(x) = h(x) + g(x). """
        return self.h(start.data, goal) + start.level
    
    def h(self, start, goal):
        """ Calculates the heuristic value h(x), i.e., the number of misplaced tiles. """
        temp = 0
        for i in range(self.n):
            for j in range(self.n):
                if start[i][j] != goal[i][j] and start[i][j] != '_':
                    temp += 1
        return temp
    
    def process(self):
        """ Accept start and goal puzzle state and start solving. """
        print("Enter the start state matrix \n")
        start = self.accept()
        print("Enter the goal state matrix \n")        
        goal = self.accept()
        
        start_node = Node(start, 0, 0)
        start_node.fval = self.f(start_node, goal)
        
        """ Put the start node in the open list. """
        self.open.append(start_node)
        
        while True:
            if not self.open:
                print("No solution found.")
                return
            
            cur = self.open[0]
            
            # Print the current state of the board.
            print("\nCurrent state:")
            for i in cur.data:
                print(" ".join(i))
            print(f"Number of misplaced tiles: {self.h(cur.data, goal)}\n")
            
            # If the current state matches the goal state, we have reached the solution.
            if self.h(cur.data, goal) == 0:
                print("\nGoal reached!")
                print("Final board:")
                for i in cur.data:
                    print(" ".join(i))
                break
            
            # Generate the children nodes and add them to the open list.
            for child in cur.generate_child():
                child.fval = self.f(child, goal)
                self.open.append(child)
            
            self.closed.append(cur)
            del self.open[0]
            
            # Sort the open list based on f-value (f = g + h).
            self.open.sort(key=lambda x: x.fval, reverse=False)


# Driver code
if __name__ == "__main__":
    n = int(input("Enter the size of the puzzle (n x n): "))
    puzzle = Puzzle(n)
    puzzle.process()
