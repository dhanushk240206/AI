import heapq

# Goal state (target configuration)
GOAL_STATE = [[1, 2, 3], 
              [4, 5, 6], 
              [7, 8, 0]]

# Manhattan Distance Heuristic
def manhattan(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val == 0:
                continue
            goal_x = (val - 1) // 3
            goal_y = (val - 1) % 3
            distance += abs(goal_x - i) + abs(goal_y - j)
    return distance

# Check if the current state is the goal state
def is_goal(state):
    return state == GOAL_STATE

# Find neighbors (possible moves from current state)
def get_neighbors(state):
    neighbors = []
    # Find the position of the blank tile (0)
    x, y = [(ix, iy) for ix, row in enumerate(state) for iy, i in enumerate(row) if i == 0][0]
    # Possible moves for the blank tile: up, down, left, right
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]  # Create a new state
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]  # Swap blank with neighbor
            neighbors.append(new_state)
    return neighbors

# A* search algorithm to solve the puzzle
def solve_puzzle(start):
    # Priority queue to store the states (open set)
    heap = []
    # Push initial state into the priority queue with f(n) = g(n) + h(n)
    heapq.heappush(heap, (manhattan(start), 0, start, []))  # f(n), g(n), state, path to get there
    visited = set()  # Set to store visited states to avoid reprocessing
    
    while heap:
        est_total, cost, state, path = heapq.heappop(heap)  # Pop the state with lowest f(n)
        key = str(state)
        
        # Skip the state if it has already been visited
        if key in visited:
            continue
        visited.add(key)
        
        # If we reached the goal state, return the solution path
        if is_goal(state):
            return path + [state]
        
        # Explore the neighbors
        for neighbor in get_neighbors(state):
            # Push each neighbor to the priority queue
            heapq.heappush(heap, (cost + 1 + manhattan(neighbor), cost + 1, neighbor, path + [state]))

    # If no solution found
    return None

# Function to print the puzzle state
def print_state(state):
    for row in state:
        print(row)
    print()

# Example initial state (starting configuration)
initial_state = [
    [1, 2, 3],
    [4, 0, 6],
    [7, 5, 8]
]

# Print the initial state
print("Initial State:")
print_state(initial_state)

# Solve the puzzle
solution = solve_puzzle(initial_state)

if solution:
    print("Solution found in {} steps:".format(len(solution) - 1))
    for step, state in enumerate(solution):
        print(f"Step {step}:")
        print_state(state)
else:
    print("No solution found.")
